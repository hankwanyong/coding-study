package effectivejava.chapter10.item76;

/**
 * 
 * 가능한 한 실패 원자적으로 만들라
 * @author 박민영
 *
 */
public class Item76Main {
	/*
	 * *****호출된 메서드가 실패하더라도, 해당 객체는 호출 전 상태를 유지해야 한다.
	 * 이러한 특성을 실패원자적 이라고 한다.
	 * 
	 * 메서드를 실패 원자적으로 만드는 방법은 다양하다.
	 * 1. 불변 객체로 설계하는 것.(아이템 17)
	 * 2. 가변객체의 메서드를 실패 원자적으로 하는 방법은 작업 수행에 앞서 매개변수의 유효성을 검사하는것.(아이템 49)
	 * 예시로 Stack.pop메서드를 확인
	 * 
	 * public Object pop() {                    
	 * 	if(size == 0) {                      
	 * 		throw new EmptyStackException(); 
	 * 	}                                    
	 * 	Object result = elements[--size];    
	 * 	elements[size] = null;//다 쓴 참조객체 해제  
	 * 	return result;                       
	 * }                                        
	 * 
	 * 이 메서드는 처음의 if문에서 size의 값을 확인하여 0 이면 예외를 던진다.
	 * 이 부분이 없더라도 스택이 비었다면 여전히 예외를 던지지만 size의 값이 음수가 되어 다음번 호출도 실패하게 되고,
	 * 이때 던지는 ArrayIndexOutOfBoundsException은 추상화 수준에 어울리지 않다고 볼 수 있다.(아이템 73)
	 * 
	 * 위와 비슷한 취지로 실패 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법도 있다.
	 * 
	 * 3. 임시 복사본에서 작업을 수행한 다음 작업이 완료되면 원래 객체와 교환하는 것.
	 * 4. 작업 도중 발생하는 실패를 가로채는 복구코드를 작성하여 작업 전 상태로 되돌리는 방법.
	 *  - 주로 디스크 기반의 내구성을 보장해야하는 자료구조에 쓰이는데, 자주 쓰이는 방법은 아니다.
	 * 
	 * 실패 원자성은 일반적으로 권장되는 덕목이지만 항상 달성할 수 있는것은 아니다.
	 * 예를 들어 두 스레드가 동기화 없이 같은 객체를 동시에 수정한다면 그 객체의 일관성이 깨질 수 있다.
	 * 따라서 ConcurrentModificationException 을 잡아냈다고해서 그 객체가 여전히 쓸 수 없는 상태라고 가정해서는 안된다.
	 * Error는 복구할 수 없으므로 AssertionError에 대해서는 실패 원자적으로 만들려는 시도조차 필요 없다. 
	 * 
	 * 실패 원자적으로 만들 수 있더라고 항상 그리 해야 하는 것도 아니다.
	 * 실패 원자성을 달성하기 위한 비용이나 복잡도가 큰 경우도 있기 때문이다.
	 * 
	 * 메서드 명세에 기술한 예외라면 설혹 예외가 발생하더라도 객체의 상태는 메서드 호출 전과 똑같이 유지돼야 한다는 것이 기본 규칙이다.
	 * 이 규칙을 지키지 못한다면 실패시의 객체 상태를 API 설명에 명시해야 한다.
	 * 
	 * */
	
}	
