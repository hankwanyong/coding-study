package effectivejava.chapter12.item88;

public class Item88Main {

	/*
	 * 아이템 88 readObject 메소드는 방어적으로 작성하라.
	 * 
	 *  "아이템 50. 적시에 방어적 복사본을 만들라" 에서는 불변식을 지키고 불변을 유지한 날짜 클래스를 만들기 위해 
	 *  생성자와 접근자(getter)에서 Date 객체를 방어적으로 복사하도록 했다. -> Period 클래스 참고
	 *  ->물리적 표현과 논리적 표현이 같기 때문에 기본 직렬화 형태를 사용해도 무방하다. 따라서 Serializable만 구현하면 될 것 같다. 
	 *    하지만 실제로는 불변식을 보장하지 못하게 된다. readObject가 또 다른 public 생성자이기 때문이다.
	 * 
	 *  - readObject 메소드는 실질적으로 다른 public 생성자이기 때문에 다른 생성자와 똑같은 수준으로 주의를 기울여야 한다.
	 *  
	 *  - readObject 는 매개변수로 바이트 스트림을 받는 생성자로 볼 수 있다.
	 *    보통 바이트 스트림은 정상적으로 생성된 인스턴스를 직렬화해서 만들어진다. 
	 *    하지만 불변을 깨뜨릴 의도로 만들어진 바이트 스트림을 받으면 문제가 생긴다. 
	 *    정상적인 방법으로는 만들어낼 수 없는 객체를 생성할 수 있기 때문이다.
	 *    단순하게 앞서 살펴본 Period 클래스에 Serializable 구현을 추가했다고 가정했을 때, BogusPeriod클래스는 불변식을 깨뜨리는 공격을 할 수 있다.
	 *    ->문제의 원인은 Period의 readObject 메서드가 방어적 복사를 하지 않음에 있다. 
	 *      역직렬화를 할 때는 클라이언트가 접근해서는 안 되는 객체 참조를 갖는 필드는 모두 방어적으로 복사를 해야 한다.
	 *  
	 *  - 그럼 언제 기본 readObject를 사용할까?
	 *     transient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사를 없이도 필드에 대입하는 public 생성자를 추가해도 괜찮다고 판단되면 기본 readObject 메서드를 사용해도 된다.
	 *     아닌 경우 직접 readObject 메서드를 정의하여 생성자에서 수행했어야 할 모든 유효성 검사와 방어적 복사를 수행해야 한다. 
	 *     가장 추천되는 것은 직렬화 프록시 패턴을 사용하는 것이다. 역직렬화를 안전하게 만드는 데 필요한 노력을 줄여준다.
	 *     final이 아닌 직렬화 가능한 클래스라면 생성자처럼 readObject 메서드도 재정의(overriding) 가능한 메서드를 호출해서는 안 된다. 
	 *     하위 클래스의 상태가 완전히 역직렬회되기 전에 하위 클래스에서 재정의된 메서드가 실행되기 때문이다.
	 *  
	 *  - 안전한 readObject 메소드를 작성하는 지침은 다음과 같다.
	 *    - private 이어야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사하라. 불변 클래스 내의 가변 요소가 여기 속한다.
	 *    - 모든 불변식을 검사하여 어긋난게 발견되면, InvalidObjectException 을 던진다. 방어적 복사 다음에는 반드시 불변식 검사가 뒤따라야 한다.
	 *    - 역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면, ObjetInputValidation 인터페이스를 사용하라.
	 *    - 직접적이든 간접적이든, 재정의 할 수 있는 메소드는 호출하지말자.
	 *  
	 * 
	 */
	

}
