package effectivejava.chapter12.item86;

import java.io.InvalidObjectException;

public class Item86Main {

	/*
	 * 아이템 86 Serializable을 구현할지는 신중히 결정하라.
	 * 
	 * - Serializable 을 구현하면 Release 한 뒤에는 수정하기 어렵다. 
	 *   직렬화 형태가 최소 적용 당시 클래스의 내부 구현 방식에 영원히 묶여버리기 때문이다.
	 * 
	 * - Serializable 는 버그와 보안 구멍이 생길 위험이 높다. 
	 *   역직렬화는 ‘숨은 생성자’ 이기 때문에, 생성자에서 구축한 불변식을 모두 보장해야하고, 생성 도중 공격자가 객체내부를 들여다 볼 수 없도록 해야 한다. 라는 사실을 떠올리기 어렵다. 
	 *   즉 불변식이 깨지고, 허가되지 않는 접근에 쉽게 노출된다.
	 * 
	 * - Serializable 는 해당 클래스의 신버전을 Release 할 때 테스트할 것이 늘어난다. 
	 *   구버전으로 역직렬화가 가능한지 등을 테스트 해야하기 때문이다.
	 *   
	 * - 상속용으로 설계된 클래스는 대부분 Serializable 를 구현하면 안되며, 인터페이스도 대부분 Serializable을 확장해서는 안된다. 
	 *   *)Serializable을 구현한 클래스만 지원하는 프레임워크를 사용하는 상황이라면 별다른 방도가 없기때문에 이 규칙을 어겨야하는 상황도 있다.
	 *   
	 * - 내부 클래스(아이템 24)는 직렬화를 구현하지 말아야 한다.
	 * 
	 */
	
	/*
	 *  만약 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하다면 주의할 점
	 *  - 인스턴스 필드 값 중 불변식을 보장해야할 게 있다면 
	 *    -> 반드시 하위클래스에서 finalize 메서드를 재정의하지 못하게 해야 한다. 즉, finalize 메서드를 자신이 재정의하면서 final로 선언하면 된다.
	 *  - 인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 다음의 readObjectNoData 메서드를 반드시 추가해야한다.
	 *  
	 *  코드 86-1 상태가 있고, 확장 가능하고, 직렬화 가능한 클래스용 readObjectNoData 메서드
	 *   - 이 메서드는 자바 4에 추가된 것으로, 기존의 직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 드문 경우를 위한 메서드다.
	 */
	 private void readObjectNoData() throws InvalidObjectException{
		 throw new InvalidObjectException("스트림 데이터가 필요합니다.");
	 }
	 
	 /**
	  * 핵심 정리
	  * 
	  * Serializable은 구현한다고 선언하기는 아주 쉽지만, 그것은 눈속임일 뿐이다.
	  * 한 클래스의 여러 버전이 상호작용할 일이 없고 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등, 보호된 환경에서만 쓰일 클래스가 아니라면
	  * Serializable 구현은 아주 신중하게 이뤄져야 한다.
	  * 상속할 수 있는 클래스라면 주의사항이 더욱 많아진다.
	  */
	

}
